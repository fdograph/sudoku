{"version":3,"sources":["Logic/SudokuGame.ts","Board/index.tsx","Main/index.tsx","index.tsx"],"names":["DIFFICULTY","shouldUnsolve","difficulty","coin","Math","random","EASY","MEDIUM","HARD","generateEmptyBoard","board","List","i","row","Array","fill","set","getCellValue","col","cell","get","undefined","Error","updateCell","num","update","isValid","m","floor","n","isEmpty","findCandidates","found","Set","add","subtract","sort","toSet","solve","candidates","solvedBoard","StyledBoard","styled","div","StyledCell","StyledHints","StyledInput","input","isSelected","coords","Hints","className","join","Board","hints","updateCoords","updateBoard","onKeyUp","useCallback","e","Number","key","replace","matrix","useMemo","map","y","x","classnames","toArray","value","onFocus","flatten","StyledScene","Main","useState","unsolve","b","generateBoard","setBoard","selectedCell","setSelectedCell","Fragment","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.4771c8e4.chunk.js","sourcesContent":["import { List, Set } from 'immutable';\nimport { BoardMatrix, Coords } from 'types';\n\nconst EMPTY_VALUE = 0;\nconst BOARD_SIZE = 9;\n\nexport enum DIFFICULTY {\n  EASY,\n  MEDIUM,\n  HARD,\n}\n\nfunction shouldUnsolve(difficulty: DIFFICULTY): boolean {\n  const coin = Math.random();\n\n  switch (difficulty) {\n    case DIFFICULTY.EASY:\n      return coin > 0.5;\n    case DIFFICULTY.MEDIUM:\n      return coin > 0.4;\n    case DIFFICULTY.HARD:\n      return coin > 0.2;\n  }\n}\n\nexport function generateEmptyBoard(): BoardMatrix {\n  let board: BoardMatrix = List();\n\n  for (let i = 0; i < BOARD_SIZE; i++) {\n    const row = List(Array<number>(BOARD_SIZE).fill(EMPTY_VALUE));\n    board = board.set(i, row);\n  }\n\n  return board;\n}\n\nexport function generateBoard(\n  difficulty: DIFFICULTY = DIFFICULTY.MEDIUM\n): BoardMatrix {\n  const unsolve = (b: BoardMatrix): BoardMatrix => {\n    for (let y = 0; y < BOARD_SIZE; y++) {\n      for (let x = 0; x < BOARD_SIZE; x++) {\n        if (shouldUnsolve(difficulty)) {\n          b = updateCell(b, x, y, EMPTY_VALUE);\n        }\n      }\n    }\n\n    return b;\n  };\n\n  return unsolve(solve(generateEmptyBoard())!);\n}\n\nexport function getCellValue(\n  board: BoardMatrix,\n  col: number,\n  row: number\n): number {\n  const cell = board.get(row)?.get(col);\n\n  if (cell === undefined) {\n    throw new Error(`No cell was found at: {x: ${col}, y: ${row}}`);\n  }\n\n  return cell;\n}\n\nexport function updateCell(\n  board: BoardMatrix,\n  col: number,\n  row: number,\n  num: number\n): BoardMatrix {\n  return board.update(row, row => row.set(col, num));\n}\n\nexport function isValid(\n  board: BoardMatrix,\n  col: number,\n  row: number,\n  num: number\n): boolean {\n  if (num < 1 || num > 9) {\n    return false;\n  }\n\n  for (let i = 0; i < BOARD_SIZE; i++) {\n    const m = 3 * Math.floor(row / 3) + Math.floor(i / 3);\n    const n = 3 * Math.floor(col / 3) + (i % 3);\n    if (\n      (i !== col && getCellValue(board, i, row) === num) ||\n      (i !== row && getCellValue(board, col, i) === num) ||\n      (n !== col && m !== row && getCellValue(board, n, m) === num)\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function isEmpty(board: BoardMatrix, col: number, row: number): boolean {\n  return getCellValue(board, col, row) === EMPTY_VALUE;\n}\n\nexport function isBoardSolved(board: BoardMatrix): boolean {\n  const goodRow = Set<number>([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n  return board.every(row => row.toSet().equals(goodRow));\n}\n\nexport function findCandidates(\n  board: BoardMatrix,\n  col: number,\n  row: number\n): Set<number> {\n  let found = Set<number>();\n\n  for (let i = 0; i < BOARD_SIZE; i++) {\n    const m = 3 * Math.floor(row / 3) + Math.floor(i / 3);\n    const n = 3 * Math.floor(col / 3) + (i % 3);\n\n    found = found\n      .add(getCellValue(board, i, row))\n      .add(getCellValue(board, col, i))\n      .add(getCellValue(board, n, m));\n  }\n\n  return Set<number>([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    .subtract(found)\n    .sort(() => Math.random() - 0.5)\n    .toSet();\n}\n\nexport function solve(board: BoardMatrix): BoardMatrix | undefined {\n  for (let row = 0; row < BOARD_SIZE; row++) {\n    for (let col = 0; col < BOARD_SIZE; col++) {\n      const cell = getCellValue(board, col, row);\n      if (cell === EMPTY_VALUE || !isValid(board, col, row, cell)) {\n        const candidates = findCandidates(board, col, row);\n        for (const cand of candidates) {\n          const solvedBoard = solve(updateCell(board, col, row, cand));\n          if (solvedBoard !== undefined) {\n            return solvedBoard;\n          }\n        }\n        return undefined;\n      }\n    }\n  }\n\n  return board;\n}\n\nexport function findErrors(board: BoardMatrix): Set<Coords> {\n  let errs = Set<Coords>();\n  for (let row = 0; row < BOARD_SIZE; row++) {\n    for (let col = 0; col < BOARD_SIZE; col++) {\n      if (!isValid(board, col, row, getCellValue(board, col, row))) {\n        errs = errs.add({ row, col });\n      }\n    }\n  }\n\n  return errs;\n}\n\nexport function cleanErrors(\n  board: BoardMatrix,\n  errs: Set<Coords>\n): BoardMatrix {\n  return errs.reduce<BoardMatrix>(\n    (b, coords) => updateCell(b, coords.col, coords.row, EMPTY_VALUE),\n    board\n  );\n}\n\nexport function solveErrors(\n  board: BoardMatrix,\n  errs: Set<Coords>\n): BoardMatrix {\n  return errs.reduce<BoardMatrix>((b, coords) => {\n    const candidates = findCandidates(b, coords.col, coords.row);\n    return candidates.size\n      ? updateCell(b, coords.col, coords.row, candidates.first())\n      : b;\n  }, board);\n}\n\nexport function eachCell(\n  fn: (r: number, c: number) => boolean | undefined\n): void {\n  for (let row = 0; row < BOARD_SIZE; row++) {\n    for (let col = 0; col < BOARD_SIZE; col++) {\n      if (fn(row, col) === false) {\n        break;\n      }\n    }\n  }\n}\n","import React, { useCallback, useMemo } from 'react';\nimport styled from 'styled-components';\nimport classnames from 'classnames';\nimport { BoardMatrix, Coords } from 'types';\nimport { updateCell, findCandidates, isValid, isEmpty } from 'Logic/SudokuGame';\n\nconst StyledBoard = styled.div`\n  display: grid;\n  grid-template-columns: repeat(9, 1fr);\n  grid-template-rows: repeat(9, 1fr);\n  gap: 0.125em;\n  justify-items: stretch;\n  background: #111;\n`;\n\nconst StyledCell = styled.div`\n  position: relative;\n  display: flex;\n  flex-direction: row;\n  align-items: stretch;\n  align-content: stretch;\n  justify-content: stretch;\n  text-align: center;\n  background: #1d1d1d;\n\n  &.is-invalid {\n    background: rgb(255, 111, 111);\n  }\n\n  &.is-empty {\n    background: rgb(34, 34, 34);\n  }\n\n  &.is-selected {\n    background: #000;\n    &.is-invalid {\n      background: rgb(255, 111, 111);\n    }\n  }\n\n  &:hover .sudoku--cell-hints {\n    display: block;\n  }\n`;\n\nconst StyledHints = styled.div`\n  position: absolute;\n  min-width: 130%;\n  width: max-content;\n  text-align: center;\n  z-index: 10;\n  top: -3em;\n  left: 50%;\n  transform: translateX(-50%);\n  background: #ccc;\n  color: #222;\n  padding: 0.5em;\n  border-radius: 0.25em;\n  display: none;\n\n  span {\n    display: block;\n  }\n\n  span:first-child {\n    font-size: 0.75em;\n  }\n\n  span:empty::before {\n    content: '-';\n  }\n`;\n\nconst StyledInput = styled.input`\n  display: flex;\n  width: 100%;\n  height: 100%;\n  border: none;\n  outline: none;\n  padding: 0;\n  margin: 0;\n  background: transparent;\n  text-align: center;\n  color: #ddd;\n  font-size: 1.5em;\n  font-weight: bold;\n`;\n\ninterface IBoardProps {\n  board: BoardMatrix;\n  coords: Coords;\n  hints: boolean;\n  updateCoords: (c: Coords) => void;\n  updateBoard: (b: BoardMatrix) => void;\n}\n\nconst isSelected = (col: number, row: number, coords: Coords): boolean => {\n  return col === coords.col && row === coords.row;\n};\n\nconst Hints: React.FC<{ candidates: number[] }> = ({ candidates }) => (\n  <StyledHints className=\"sudoku--cell-hints\">\n    <span>Hints:</span>\n    <span>{candidates.join(' - ')}</span>\n  </StyledHints>\n);\n\nconst Board: React.FC<IBoardProps> = ({\n  board,\n  coords,\n  hints,\n  updateCoords,\n  updateBoard,\n}) => {\n  const onKeyUp = useCallback(\n    (col: number, row: number) => (e: React.KeyboardEvent) => {\n      updateBoard(\n        updateCell(board, col, row, Number(e.key.replace(/\\D/g, '')))\n      );\n    },\n    [board, updateBoard]\n  );\n\n  const matrix = useMemo(() => {\n    return board\n      .map((row, y) =>\n        row.map((cell, x) => (\n          <StyledCell\n            className={classnames('sudoku--cell', {\n              'is-selected': isSelected(x, y, coords),\n              'is-invalid':\n                !isEmpty(board, x, y) && !isValid(board, x, y, cell),\n              'is-empty': isEmpty(board, x, y),\n            })}\n            key={`block:${x}:${y}`}\n          >\n            {hints && isSelected(x, y, coords) ? (\n              <Hints candidates={findCandidates(board, x, y).toArray()} />\n            ) : null}\n            <StyledInput\n              className=\"sudoku--cell-input\"\n              key={`cell:${x}:${y}`}\n              value={cell || '-'}\n              onFocus={() =>\n                !isSelected(x, y, coords) && updateCoords({ col: x, row: y })\n              }\n              onKeyUp={onKeyUp(x, y)}\n            />\n          </StyledCell>\n        ))\n      )\n      .flatten(false)\n      .toArray();\n  }, [board, coords, hints, onKeyUp, updateCoords]);\n\n  return <StyledBoard className=\"sudoku--board\">{matrix}</StyledBoard>;\n};\n\nexport default Board;\n","import React, { useState } from 'react';\nimport styled from 'styled-components';\n\nimport './styles.css';\nimport Board from '../Board';\nimport { BoardMatrix, Coords } from '../types';\nimport { DIFFICULTY, generateBoard } from '../Logic/SudokuGame';\n\nconst StyledScene = styled.div`\n  display: flex;\n  padding: 1em;\n  justify-content: center;\n  align-items: center;\n  background: #222;\n\n  .sudoku--board {\n    width: 90vmin;\n    height: 90vmin;\n  }\n`;\n\nconst Main: React.FC = () => {\n  const [board, setBoard] = useState<BoardMatrix>(\n    generateBoard(DIFFICULTY.MEDIUM)\n  );\n  const [selectedCell, setSelectedCell] = useState<Coords>({\n    col: 0,\n    row: 0,\n  });\n\n  return (\n    <React.Fragment>\n      <StyledScene>\n        <Board\n          board={board}\n          coords={selectedCell}\n          hints={true}\n          updateCoords={setSelectedCell}\n          updateBoard={setBoard}\n        />\n      </StyledScene>\n    </React.Fragment>\n  );\n};\n\nexport default Main;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport Main from './Main';\n\nReactDOM.render(<Main />, document.getElementById('root'));\n"],"sourceRoot":""}